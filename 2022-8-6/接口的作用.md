接口的作用：
第一、使某些实现类具有我们想要的功能，比如说，实现了 Cloneable 接口的类具有拷贝的功能，实现了 Comparable 或者 Comparator 的类具有比较功能。；
第二、通过接口可以实现多重继承的目的；
第三、实现多态。多态就是同一个事件发生在不同的对象上会产生不同的结果，鼠标左键点击窗口上的 X 号可以关闭窗口，点击超链接却可以打开新的网页。

多态可以通过继承（extends）的关系实现，也可以通过接口的形式实现。

抽象类和接口的区别：


1）语法层面上

接口中不能有 private 和 protected 修饰的方法，抽象类中可以有。
接口中的变量只能是隐式的常量，抽象类中可以有任意类型的变量。
一个类只能继承一个抽象类，但却可以实现多个接口。


2）设计层面上

抽象类是对类的一种抽象，继承抽象类的子类和抽象类本身是一种 is-a 的关系。

接口是对类的某种行为的一种抽象，接口和类之间并没有很强的关联关系，举个例子来说，所有的类都可以实现 Serializable 接口，从而具有序列化的功能，但不能说所有的类和 Serializable 之间是 is-a 的关系。

static 关键字的作用可以用一句话来描述：‘方便在没有创建对象的情况下进行调用，包括变量和方法’。

如果 main 方法不是静态的，就意味着 Java 虚拟机在执行的时候需要先创建一个对象才能调用 main 方法，而 main 方法作为程序的入口，创建一个额外的对象显得非常多余。

第一，静态内部类不能访问外部类的所有成员变量；第二，静态内部类可以访问外部类的所有静态变量，包括私有静态变量。第三，外部类不能声明为 static。

this 关键字有很多种用法，其中最常用的一个是，它可以作为引用变量，指向当前对象。

调用当前类的方法；
this() 可以调用当前类的构造方法；
this 可以作为参数在方法中传递；
this 可以作为参数在构造方法中传递；
this 可以作为方法的返回值，返回当前类的对象。

this 关键字作为方法的返回值的时候，方法的返回类型为类的类型。

super：
指向父类对象；
调用父类的方法；
super() 可以调用父类的构造方法。

final 和 static 一起修饰的成员变量叫做常量，常量名必须全部大写。

为什么 String 类要设计成 final ？

为了实现字符串常量池
为了线程安全
为了 HashCode 的不可变性

我们通常所说的“字符串是不可变的”是指“字符串对象是不可变的”。

对象存储在堆（heap）中，而对象的引用存储在栈（stack）中。


对象引用存储的是对象在内存中的地址。

字符串一旦在内存中被创建，就无法被更改。String 类的所有方法都不会改变字符串本身，而是返回一个新的字符串对象。如果需要一个可修改的字符序列，建议使用 StringBuffer 或 StringBuilder 类代替 String 类，否则每次创建的新字符串对象会导致 Java 虚拟机花费大量的时间进行垃圾回收。

当比较两个字符串对象的内容是否相等时，请使用 .equals() 方法。

当比较两个字符串对象是否相等时，请使用“==”操作符。.equals() 方法在比较的时候需要判 null，而“==”操作符则不需要。

Objects.equals() 这个静态方法的优势在于不需要在调用之前判空。

.contentEquals() 的优势在于可以将字符串与任何的字符序列（StringBuffer、StringBuilder、String、CharSequence）进行比较。

不可变类有很多优点，就像之前提到的 String 类那样，尤其是在多线程环境下，它非常的安全。尽管每次修改都会创建一个新的对象，增加了内存的消耗，但这个缺点相比它带来的优点，显然是微不足道的。


<?> 无限制通配符
<? extends E> extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类
<? super E> super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类

// 使用原则《Effictive Java》
// 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限
1. 如果参数化类型表示一个 T 的生产者，使用 < ? extends T>;
2. 如果它表示一个 T 的消费者，就使用 < ? super T>；
3. 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。

注解的生命周期有 3 种策略，定义在 RetentionPolicy 枚举中。”

1）SOURCE：在源文件中有效，被编译器丢弃。

2）CLASS：在编译器生成的字节码文件中有效，但在运行时会被处理类文件的 JVM 丢弃。

3）RUNTIME：在运行时有效。这也是注解生命周期中最常用的一种策略，它允许程序通过反射的方式访问注解，并根据注解的定义执行相应的代码。

ArrayList 和 LinkedList 删除元素时究竟谁快？

从集合头部删除元素时，ArrayList 花费的时间比 LinkedList 多很多；

从集合中间位置删除元素时，ArrayList 花费的时间比 LinkedList 少很多；

从集合尾部删除元素时，ArrayList 花费的时间比 LinkedList 少一点。

新增和删除结果一致，在不考虑扩容、性能情况下。

Java中的Iterator和Iterable区别
从英文单词的后缀语法上来看，（Iterable）able 表示这个 List 是支持迭代的，而 （Iterator）tor 表示这个 List 是如何迭代的。

fail-fast 是一种保护机制，可以通过 for-each 循环删除集合的元素的方式验证这种保护机制。

那也就是说，for-each 本质上是一种语法糖，遍历集合时很方面，但并不适合拿来操作集合中的元素（增删）。